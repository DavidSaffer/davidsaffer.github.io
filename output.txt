Filename: index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PixelBomber</title>
    <link rel="icon" href="favicon.ico">
    <link rel="stylesheet" href="initial_page.css">
    <link rel="stylesheet" href="lobby.css">
    <link rel="stylesheet" href="game.css">
</head>
<body>
    <div id="initial_page">
        <header>
            <div class="logo">Pixel Bomber</div>
        </header>
        <main>
            <div class="nickname_box">
                <h1>Choose nickname</h1>
                <input type="text" id="nickname" placeholder="david">
                <button id="go_button">Go!</button>
            </div>
        </main>        
    </div>

    <div id="lobby" style="display:none">
        
        <div class="lobby-footer">
            <button id="create_lobby_button">Create Lobby</button>
            <button id="join_lobby_button">Join Lobby</button>
        </div>
        <div id="lobby_modal" class="modal">
            <div class="modal_content">
                <!-- <span class="close" id="close_create_room_modal">&times;</span> -->
                <h2 id="lobby_modal_title">Title</h2>
                <input type="text" id="lobby_modal_code" readonly value="YourLobbyCodeHere" style="text-align: center;">
                <button id="lobby_modal_coppy_button">Copy</button>
                <!-- <p id="lobby_modal_text"></p> -->
                <input type="text" id="lobby_modal_input" placeholder="Lobby Code">
                <button id="lobby_modal_button">Start Game</button>
            </div>
        </div>
    </div>

    <div id="game" style="display:none">

        <button id="settingsButton" class="settings-button">Settings</button>

        <div id="game_modal" class="modal">
            <div class="game_modal_content">
                <div class="game_modal_header">
                    <span id="game_modal_lobby_code">Lobby Code: ABCD1234</span>
                    <button id="game_modal_leave_button" class="team-selection-leave-button">Leave</button>
                </div>
                <div class="game_modal_team_selection">
                    <div class="team_column">
                        <button class="game_modal_join_button red">Join Red Team</button>
                        <div class="player_list red_team">
                            <!-- Default Red Team Members -->
                            <!-- <div class="player">Red Player 1</div>
                            <div class="player">Red Player 2</div> -->
                        </div>
                    </div>
                    <div class="team_column">
                        <button class="game_modal_join_button yellow">Join Spectators</button>
                        <div class="player_list spectators_team"></div>
                    </div>
                    <div class="team_column">
                        <button class="game_modal_join_button blue">Join Blue Team</button>
                        <div class="player_list blue_team"></div>
                    </div>
                    
                </div>
            </div>
        </div>

        
        
        <!-- <p>Game!!</p>
        <button id="game_button">Send Message</button> -->
        <!-- <input type="text" id="game_input" placeholder="Message"> -->
        <div id="playerInfoContainer">
            <div class="player-info">
                <p>Test Player 1</p>
                <p>Score: 3000</p>
                <p>Lives: 5</p>
            </div>
            <div class="player-info">
                <p>Test Player 2</p>
                <p>Score: 4500</p>
                <p>Lives: 3</p>
            </div>
            
            
            <!-- Add more default player data as needed -->
        </div>
        
        <canvas id="game_canvas" width="80" height="80"></canvas>

    </div>
    
    <!-- <script src="/socket.io/socket.io.js"></script> -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="client.js"></script>
</body>
</html>---- End of index.html ----

Filename: client.js
const AppConfig = {
    canvasWidth: 16 * 100,
    canvasHeight: 9 * 100
    // Add more configuration settings as needed
};

const GameConfig = {
    enemySpawnRate: 600, // Spawn an enemy every second
    enemySpeed: 10,
    coinSpawnRate: 200, // Spawn a coin every 0.5 seconds
    coinLifespan: 5000, // 5 seconds


};

class Player {
    constructor(cWidth, cHeight, x, y, id, basePlayerScale = 0.05 ) {
        this.cWidth = cWidth;
        this.cHeight = cHeight;

        this.x = x;
        this.y = y;
        this.id = id;

        this.left = false;
        this.right = false;
        this.up = false;
        this.down = false;
        this.action = false;

        this.score = 0;
        this.lives = 3;
        this.name = '...';

        this.moveSpeed = 15;

        this.dx = 0;
        this.dy = 0;

        this.basePlayerScale = basePlayerScale;
        this.playerScale = basePlayerScale;
        const size = Math.min(cWidth, cHeight);
        this.width = size * basePlayerScale; // Example: 5% of canvas width
        this.height = size * basePlayerScale; // Same for height, adjust percentage as needed

        this.ready = false;

        // Missile shooting cooldown
        this.missileCooldown = 100; // 500 ms cooldown
        this.lastMissileShot = 0; // Timestamp of the last shot
    }

    loseLife() {
        this.lives -= 1;
    }

    reset() {
        this.lives = 3;
        this.score = 0;
    }

    draw(ctx) {
        ctx.fillStyle = 'blue';
        ctx.fillRect(this.x, this.y, this.width, this.height);
    }

    shootMissiles(missilesArray) {
        const directions = ['up', 'down', 'left', 'right'];
        directions.forEach(direction => {
            missilesArray.push(new Missile(this.x, this.y, direction, this.id));
        });
        this.lastMissileShot = Date.now(); // Update the timestamp of the last shot
    }

    update(){
        if (this.lives <= 0) {
            this.dx = 0;
            this.dy = 0;
            return;
        }

        this.dx = 0;
        this.dy = 0;
        

        if (this.left) {
            this.dx += -this.moveSpeed;
        }
        if (this.right) {
            this.dx += this.moveSpeed;
        }
        if (this.up) {
            this.dy += -this.moveSpeed;
        }
        if (this.down) {
            this.dy += this.moveSpeed;
        }
        // Shooting missiles
        // if (this.action && Date.now() - this.lastMissileShot > this.missileCooldown) {
        //     this.shootMissiles(misslesArray);
        // }

        this.x += this.dx;
        this.y += this.dy;
        

        // Handle boundaries
        this.x = Math.max(0, Math.min(this.x, this.cWidth - this.width));
        this.y = Math.max(0, Math.min(this.y, this.cHeight - this.height));

    }
}

class Enemy {
    constructor(cWidth, cHeight, speed, enemieScale = .03) {
        this.enemieScale = enemieScale;
        this.cWidth = cWidth;
        this.cHeight = cHeight;
        const size = Math.min(cWidth, cHeight);
        this.width = size * this.enemieScale; 
        this.height = size * this.enemieScale;
        this.speed = speed;

        this.x, this.y, this.dx, this.dy;
        const startEdge = Math.floor(Math.random() * 4);
        const isVertical = startEdge % 2 === 0;

        if (isVertical) {
            this.x = Math.random() * this.cWidth;
            this.y = startEdge === 0 ? 0 : this.cHeight;
            this.dx = 0;
            this.dy = startEdge === 0 ? speed : -speed;
        } else {
            this.x = startEdge === 1 ? this.cWidth : 0;
            this.y = Math.random() * this.cHeight;
            this.dx = startEdge === 1 ? -speed : speed;
            this.dy = 0;
        }
    }

    draw(ctx) {
        ctx.fillStyle = 'red';
        ctx.fillRect(this.x, this.y, this.width, this.height);
    }

    update() {

        this.x += this.dx;
        this.y += this.dy;

        // Remove the enemy if it goes off screen
        if (this.x < -this.width || this.x > this.cWidth ||
            this.y < -this.height || this.y > this.cHeight) {
            return false;
        }
        return true;
    }
}

class Coin {
    constructor(cWidth, cHeight, coinScale = .015) {
        this.coinScale = coinScale;
        const size = Math.min(cWidth, cHeight);
        this.originalWidth = size * this.coinScale; 
        this.originalHeight = size * this.coinScale;
        //this.originalWidth = 20; // Original size of the coin
        //this.originalHeight = 20;
        this.width = this.originalWidth;
        this.height = this.originalHeight;

        this.x = Math.random() * (cWidth - this.width); // Random position
        this.y = Math.random() * (cHeight - this.height);

        this.spawnTime = Date.now(); // Store the spawn time
        this.lastShrinkTime = Date.now();
        this.shrinkInterval = 1000; // Interval between shrinks in milliseconds
        this.lifespan = 5000; // 5 seconds in milliseconds
    }

    draw(ctx) {
        ctx.fillStyle = 'yellow'; // Color of the coin
        //ctx.fillRect(this.x, this.y, this.width, this.height);
        ctx.beginPath();
        ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 2, 0, Math.PI * 2);
        ctx.fill();
    }

    update(settings) {
        const now = Date.now();
        if (settings.coinDespawn) {
            if (settings.cointTick){
                if (now - this.lastShrinkTime > this.shrinkInterval) {
                    const elapsed = now - this.spawnTime;
                    const remainingLife = Math.max(this.lifespan - elapsed, 0);
                    const shrinkFactor = remainingLife / this.lifespan;
                    this.width = this.originalWidth * shrinkFactor;
                    this.height = this.originalHeight * shrinkFactor;
                    this.lastShrinkTime = now;
                }
            }
            else {
                const elapsed = now - this.spawnTime;
                const remainingLife = Math.max(this.lifespan - elapsed, 0);
                const shrinkFactor = remainingLife / this.lifespan;
                this.width = this.originalWidth * shrinkFactor;
                this.height = this.originalHeight * shrinkFactor;
            }
        }
    }
}

class Missile {
    constructor(x, y, direction, ownerId) {
        this.x = x;
        this.y = y;
        this.direction = direction; // 'up', 'down', 'left', 'right'
        this.speed = 40; // Adjust as needed
        this.ownerId = ownerId;
    }

    update() {
        // Update missile position based on its direction
        switch(this.direction) {
            case 'up':
                this.y -= this.speed;
                break;
            case 'down':
                this.y += this.speed;
                break;
            case 'left':
                this.x -= this.speed;
                break;
            case 'right':
                this.x += this.speed;
                break;
        }
    }
}

class Game {
    constructor(cWidth, cHeight, serverRoomName, gameConfig, context) {
        this.cWidth = cWidth;
        this.cHeight = cHeight;
        this.players = {};
        this.enemies = [];
        this.coins = [];
        this.missile = [];
        this.paused = false;
        this.gameOver = false;
        this.enemySpawnRate = gameConfig.enemySpawnRate; // Spawn an enemy every second
        this.coinSpawnRate = gameConfig.coinSpawnRate; // Spawn a coin every 0.5 seconds
        this.lastEnemySpawn = Date.now();
        this.lastCoinSpawn = Date.now();
        this.settings = { coinDespawn: true, coinTick: true };
        this.colors = ['blue', 'green', 'yellow', 'purple', 'orange', 'pink', 'brown', 'black', 'white'];
        this.interval = null;
        this.roomName = serverRoomName;
        this.connections = [];
        this.conn = null;
        this.ctx = context;
    }

    // Method to start the game loop
    start() {
        new Promise((resolve, reject) => {
            // Check periodically if there are 2 players
            let checkInterval = setInterval(() => {
                if (Object.keys(this.players).length >= 1) {
                    clearInterval(checkInterval);
                    resolve();
                }
            }, 1000); // Check every second
        })
        .then(() => {
            // Start the game interval when the promise resolves
            this.interval = setInterval(() => {
                //this.gameTick();
                // Broadcast the updated game state to the room
                renderGame(this.ctx, this.players, this.enemies, this.coins, this.missile, this.paused);
                // for (const conn of this.connections) {
                //     conn.send({ type: 'gameState', players: this.players, enemies: this.enemies, coins: this.coins, missile: this.missile, paused: this.paused });
                // }
                // if (this.conn !== null) {
                //     this.conn.send({ type: 'gameState', players: this.players, enemies: this.enemies, coins: this.coins, missile: this.missile, paused: this.paused });
                // }
            }, 1000 / 60);
        });
    }

    stop() {
        if (this.interval) {
            clearInterval(this.interval);
        }
    }

    restart() {
        // reset players
        Object.values(this.players).forEach(player => {
            player.reset();
        });
        this.enemies = [];
        this.coins = [];
        this.paused = false;
        this.gameOver = false;
        this.lastEnemySpawn = Date.now();
        this.lastCoinSpawn = Date.now();
        this.start();

    }

    addPlayer(id, x, y, playerNumber, playerName, basePlayerScale = 0.05) {
        const player = new Player(this.cWidth, this.cHeight, x, y, id, basePlayerScale);
        player.playerNumber = playerNumber;
        player.name = playerName;
        player.color = this.colors[playerNumber - 1];
        this.players[id] = player;
    }

    updatePlayer(player){
        // if (player.lives <= 0) {
        //     player.dx = 0;
        //     player.dy = 0;
        //     return;
        // }

        player.dx = 0;
        player.dy = 0;
        

        if (player.left) {
            player.dx += -player.moveSpeed;
        }
        if (player.right) {
            player.dx += player.moveSpeed;
        }
        if (player.up) {
            player.dy += -player.moveSpeed;
        }
        if (player.down) {
            player.dy += player.moveSpeed;
        }
        // Shooting missiles
        // if (this.action && Date.now() - this.lastMissileShot > this.missileCooldown) {
        //     this.shootMissiles(misslesArray);
        // }

        player.x += player.dx;
        player.y += player.dy;
        

        // Handle boundaries
        player.x = Math.max(0, Math.min(player.x, AppConfig.canvasWidth - player.width));
        player.y = Math.max(0, Math.min(player.y, AppConfig.canvasHeight - player.height));

    }

    spawnEnemy() {
        if (Date.now() - this.lastEnemySpawn > this.enemySpawnRate) {
            this.enemies.push(new Enemy(this.cWidth, this.cHeight, 10));
            this.lastEnemySpawn = Date.now();
        }
    }

    spawnCoin() {
        if (Date.now() - this.lastCoinSpawn > this.coinSpawnRate) {
            const newCoin = new Coin(this.cWidth, this.cHeight);
            this.coins.push(newCoin);
            this.lastCoinSpawn = Date.now();
        }
    }

    handleMissiles() {
        const missilesToRemove = [];
        this.missile.forEach((missile, missileIndex) => {
            // Update missile position
            missile.update();
    
            // Check if the missile is outside the game area and mark it for removal if it is
            if (missile.x < 0 || missile.x > this.cWidth || missile.y < 0 || missile.y > this.cHeight) {
                missilesToRemove.push(missileIndex);
                return; // Skip further checks for this missile
            }
    
            // Check for collisions with players
            Object.values(this.players).forEach(player => {
                // Avoid self-inflicted hits
                if (missile.ownerId === player.id) return;
    
                const hit = missile.x < player.x + player.width &&
                            missile.x + 5 > player.x && // Assuming missile width is 5
                            missile.y < player.y + player.height &&
                            missile.y + 5 > player.y; // Assuming missile height is 5
    
                if (hit) {
                    // Player hit by missile, deduct a life
                    player.loseLife();
    
                    // Emit an update to all clients about the hit
                    io.to(this.roomName).emit('playerHit', { playerId: player.id, newLives: player.lives });
    
                    // Mark missile for removal
                    missilesToRemove.push(missileIndex);
                }
            });
        });
    
        // Remove missiles that are out of bounds or have hit a player
        // Looping in reverse to avoid indexing issues while splicing
        for (let i = missilesToRemove.length - 1; i >= 0; i--) {
            this.missile.splice(missilesToRemove[i], 1);
        }
    }
    

    checkCollisions() {
        // Coin collisions
        Object.values(this.players).forEach(player => {
            if (player.lives <= 0) return; // Dead players cant collect coins
            this.coins.forEach((coin, index) => {
                if (player.x < coin.x + coin.width && player.x + player.width > coin.x &&
                    player.y < coin.y + coin.height && player.y + player.height > coin.y) {
                    player.score += 1;
                    this.coins.splice(index, 1); // Remove coin after collection
                }
            });
        });

        // Enemy collisions
        Object.values(this.players).forEach(player => {
            if (player.lives <= 0) return; // Dead players cant die more
            this.enemies.forEach((enemy, index) => {
                if (player.x < enemy.x + enemy.width && player.x + player.width > enemy.x &&
                    player.y < enemy.y + enemy.height && player.y + player.height > enemy.y) {
                    player.lives -= 1;
                    this.enemies.splice(index, 1); // Remove enemy after collision
                }
            });
        });
    }

    gameTick() {
        if (this.paused || this.gameOver) return;
        this.spawnEnemy();
        this.spawnCoin();
        this.checkCollisions();
        //this.handleMissiles();
        this.updateEntities();

        for (const conn of this.connections) {
            conn.send({ type: 'gameState', players: this.players, enemies: this.enemies, coins: this.coins, missile: this.missile, paused: this.paused });
        }
        
        
        const alivePlayers = Object.values(this.players).filter(player => player.lives > 0);
        const deadPlayers = Object.values(this.players).filter(player => player.lives <= 0);

        // Check if game should continue based on alive and dead players' scores
        let gameShouldEnd = false;
        if (alivePlayers.length === 0) {
            gameShouldEnd = true; // All players are dead, end the game
        } else if (alivePlayers.length === 1 && deadPlayers.every(deadPlayer => alivePlayers[0].score > deadPlayer.score)) {
            // Only one player is alive and has a higher score than all dead players, end the game
            gameShouldEnd = true;
        }

        if (gameShouldEnd) {
            this.gameOver = true;
            console.log("game over")
            for (const conn of this.connections) {
                conn.send({ type: 'gameOver', players: this.players });
            }
            
            //io.to(this.roomName).emit('gameOver', this.players); // Assume roomNumber is tracked per game instance
            this.stop(); // Stop the game loop
        }
    }

    updateEntities() {
        // Update coins
        const currentTime = Date.now();
        this.coins.forEach(coin => coin.update(this.settings));
        this.coins = this.coins.filter(coin => {
            const coinAge = currentTime - coin.spawnTime;
            return !(coinAge > 3000); // Keep the coin if age is less than 3 seconds
        });

        // Update enemies
        this.enemies = this.enemies.filter(enemy => enemy.update());

        // Update players
        //Object.values(this.players).forEach(player => console.log(player));
        Object.values(this.players).forEach(player => this.updatePlayer(player));

        // Handle game over condition
        const alivePlayers = Object.values(this.players).filter(player => player.lives > 0);
        if (alivePlayers.length === 0) {
            this.gameOver = true;
            // Emit gameOver event or handle it accordingly
        }
    }
}

function renderGame(ctx, players, enemies, coins, missile, paused) {
    //if no players, continue
    if (Object.keys(players).length === 0) {
        return;
    }
    //document.getElementById('pauseButton').innerText = paused ? 'Start' : 'Pause';
    ctx.clearRect(0, 0, AppConfig.canvasWidth, AppConfig.canvasHeight);
    Object.values(players).forEach((player, index) => {
        ctx.fillStyle = player.color;
        if (player.lives <= 0) {
            ctx.fillStyle = 'darkgrey';
        }
        ctx.fillRect(player.x, player.y, player.width, player.height);

        //clear playerinfo container
        const playerInfoContainer = document.querySelectorAll('.player-info')[index];
        if (playerInfoContainer) {
            // Update the text content for lives and score
            playerInfoContainer.innerHTML = `
                <p>${player.name}</p>
                <p>Score: ${player.score}</p>
                <p>Lives: ${player.lives}</p>
            `;
        }
    });
    enemies.forEach(enemy => {
        ctx.fillStyle = 'red';
        ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
    });
    coins.forEach(coin => {
        ctx.fillStyle = 'yellow';
        ctx.beginPath();
        ctx.arc(coin.x + coin.width / 2, coin.y + coin.height / 2, coin.width / 2, 0, Math.PI * 2);
        ctx.fill();
    });
    missile.forEach(missile => {
        ctx.fillStyle = 'orange'; // Or any color you like
        ctx.fillRect(missile.x, missile.y, 5, 5); // Adjust size as needed
    });
}

document.addEventListener("DOMContentLoaded", () => {


    const peer = new Peer();
      
    let name = '';
    let peerId = null;


    peer.on('open', function(id) {
        console.log('My peer ID is: ' + id);
        peerId = id;
    });

    // peer.on('data', function(data) {
    //     console.log('Received', data);
    // });
    

    // Query DOM
    // initial page
    const initial_page = document.getElementById('initial_page');
    const name_input = document.getElementById('nickname');
    const go_button = document.getElementById('go_button');

    go_button.onclick = function() {
        name = name_input.value;
        go_to_lobby();
    }

    function go_to_lobby() {
        initial_page.style.display = "none";
        lobby.style.display = "flex";
        game.style.display = "none";
    }

    // lobby page ====================================================================================
    const lobby = document.getElementById('lobby');
    
    const create_lobby_button = document.getElementById('create_lobby_button');
    const join_lobby_button = document.getElementById('join_lobby_button');
    
    const lobby_modal = document.getElementById('lobby_modal');
    const lobby_modal_title = document.getElementById('lobby_modal_title');
    // const lobby_modal_text = document.getElementById('lobby_modal_text');
    const lobby_modal_input = document.getElementById('lobby_modal_input');
    const lobby_modal_button = document.getElementById('lobby_modal_button');

    const lobby_modal_coppy_button = document.getElementById('lobby_modal_coppy_button');
    const lobby_modal_code = document.getElementById('lobby_modal_code');

    function copyLobbyCode() {
        // Copy the text inside the text field
        navigator.clipboard.writeText(lobby_modal_code.value)
            .then(() => {
                // Optionally, show a message to indicate that the code was copied
                //alert('Copied the lobby code: ' + lobby_modal_code.value);
            })
            .catch(err => {
                console.error('Could not copy text: ', err);
            });
    }

    // Set up the click event listener for the copy button
    lobby_modal_coppy_button.onclick = copyLobbyCode;


    create_lobby_button.onclick = function() {
        // Set the lobby code to the input's value
        lobby_modal_code.style.display = "block";
        lobby_modal_coppy_button.style.display = "block";
        lobby_modal_code.value = peerId; // Assuming peerId is your lobby code

        // Show the modal
        lobby_modal.style.display = "block";
        lobby_modal_title.innerText = "Lobby Code";

        // Automatically select the lobby code text for easy copying (optional)
        lobby_modal_code.select();
        lobby_modal_code.setSelectionRange(0, 99999); // For mobile devices

        lobby_modal_input.style.display = "none"; // Hide input

        lobby_modal.style.display = "block";
        lobby_modal_title.innerText = "Lobby Code";

        // lobby_modal_text.style.display = "block"; // Show text
        // lobby_modal_text.innerText = peerId;

        lobby_modal_button.onclick = function() {
            startGame();
        }
    }


    join_lobby_button.onclick = function() {
        // lobby_modal_text.style.display = "none"; // Hide text
        lobby_modal_code.style.display = "none"; // Hide text
        lobby_modal_coppy_button.style.display = "none"; // Hide button

        lobby_modal.style.display = "block";
        lobby_modal_title.innerText = "Enter Lobby Code";
        lobby_modal_input.style.display = "block"; // Show input
        lobby_modal_input.placeholder = 'Enter Lobby Code...';

        lobby_modal_button.onclick = joinGame;
        
        
    }
    // end lobby page ====================================================================================

    // Game Page =========================================================================================

    const canvas = document.getElementById('game_canvas');
    const ctx = canvas.getContext('2d');
    
    // Use values from the AppConfig object
    canvas.width = AppConfig.canvasWidth;
    canvas.height = AppConfig.canvasHeight;

    const game_input = document.getElementById('game_input');
    let conn;
    let red_team = [];
    let spectators = [];
    let blue_team = [];
    let playerColor = '';
    const game_modal_lobby_code = document.getElementById('game_modal_lobby_code');

    let userCommands = {
        left: false,
        up: false,
        right: false,
        down: false,
        action: false
    }
    let justPressed = false;
    function userInput(obj, connection) {
        document.addEventListener('keydown', function(e) {
            if (e.key === "ArrowLeft" || e.key === "a") {
                if (!obj.left) {
                    justPressed = true;
                }
                obj.left = true;
            }
            if (e.key === "ArrowUp" || e.key === "w") {
                if (!obj.up) {
                    justPressed = true;
                }
                obj.up = true;
            }
            if (e.key === "ArrowRight" || e.key === "d") {
                if (!obj.right) {
                    justPressed = true;
                }
                obj.right = true;
            }
            if (e.key === "ArrowDown" || e.key === "s") {
                if (!obj.down) {
                    justPressed = true;
                }
                obj.down = true;
            }
            if (e.key === " ") {
                if (!obj.action) {
                    justPressed = true;
                }
                obj.action = true;
            }
            if (justPressed) {
                emitUserCommands(obj, conn);
                justPressed = false;
            }
        });
    
        document.addEventListener('keyup', function(e) {
            if (e.key === "ArrowLeft" || e.key === "a") {
                obj.left = false;
            }
            if (e.key === "ArrowUp" || e.key === "w") {
                obj.up = false;
            }
            if (e.key === "ArrowRight" || e.key === "d") {
                obj.right = false;
            }
            if (e.key === "ArrowDown" || e.key === "s") {
                obj.down = false;
            }
            if (e.key === " ") {
                obj.action = false;
            }
            // Emit user commands on key up to ensure the server is updated with the new state
            emitUserCommands(obj, conn);
        });
    }
    function emitUserCommands(obj, conn){
        if (conn === undefined) {
            return;
        }
        let userCommands = {
            left: obj.left,
            up: obj.up,
            right: obj.right,
            down: obj.down,
            action: obj.action
        }
        conn.send({ type: 'userInput', id: peerId, commands: userCommands });
    }

    function startGame() {
        console.log('Starting game');
        // Main JavaScript file
        
        // Create a new game instance
        const gameInstance = new Game(AppConfig.canvasWidth, AppConfig.canvasHeight, peerId, GameConfig);
        gameInstance.ctx = ctx;
        let myPlayer = new Player(AppConfig.canvasWidth, AppConfig.canvasHeight, 100, 100, peerId, 0.05);
        myPlayer.name = name;
        userInput(myPlayer);
        gameInstance.players[peerId] = myPlayer;
        gameInstance.start();

        let gameWorker;

        if (window.Worker) {
            gameWorker = new Worker('webworker.js');

            gameWorker.onmessage = function(e) {
                if (e.data.status === 'tick') {
                    // Handle the tick - Update game logic, etc.
                    gameInstance.gameTick();
                }
            };

            // To start the game loop
            gameWorker.postMessage({ command: 'start', fps: 60 });

            // Optionally, to stop the interval when not needed
            gameWorker.postMessage({ command: 'stop' });

            // // Handle visibility change to pause/resume game loop
            // document.addEventListener('visibilitychange', () => {
            //     if (document.visibilityState === 'hidden') {
            //         gameWorker.postMessage({ command: 'stop' });
            //     } else {
            //         gameWorker.postMessage({ command: 'start', fps: 60 });
            //     }
            // });
        } else {
            console.log('Your browser does not support Web Workers.');
        }

        console.log('gameInstance: ', gameInstance);

        peer.on('connection', function(connection) {

            console.log("connected ");
            conn = connection;
            gameInstance.connections.push(conn);
            // Listen for data from the connection
            conn.on('data', function(data) {
                if (data.type === 'game_input_change') {
                    game_input.value = data.message;
                }
                if (data.type === 'team_update') {
                    red_team = data.red_team;
                    blue_team = data.blue_team;
                    spectators = data.spectators;
                    updatePlayerList('Red', red_team);
                    updatePlayerList('Blue', blue_team);
                    updatePlayerList('Spectators', spectators);
                    if (red_team.length > 0 && blue_team.length > 0) {
                        gameInstance.start();
                        gameWorker.postMessage({ command: 'start', fps: 60 });
                    }
                    myPlayer.color = playerColor;
                    conn.send({ type: 'team_update', red_team, blue_team, spectators });
                }
                if (data.type === 'initial_data_request') {
                    conn.send({ type: 'initial_data', red_team, blue_team, spectators });
                }
                if (data.type === 'playerConnect') {
                    gameInstance.players[data.myPlayer.id] = data.myPlayer;
                }
                if (data.type === 'userInput') {
                    gameInstance.players[data.id].left = data.commands.left;
                    gameInstance.players[data.id].up = data.commands.up;
                    gameInstance.players[data.id].right = data.commands.right;
                    gameInstance.players[data.id].down = data.commands.down;
                    gameInstance.players[data.id].action = data.commands.action;
                }
            });

            // // Broadcast game input changes to all connected peers
            // game_input.addEventListener('input', function() {
            //     conn.send({ type: 'game_input_change', message: game_input.value });
            // });
        });


        showGame();
        game_modal_lobby_code.innerText = `Lobby Code: ${peerId}`;
        
    }

    function joinGame() {

        const lobby_code = lobby_modal_input.value;
        game_modal_lobby_code.innerText = `Lobby Code: ${lobby_code}`;

        let myPlayer = new Player(AppConfig.canvasWidth, AppConfig.canvasHeight, 100, 100, peerId, 0.05);
        myPlayer.name = name;


        conn = peer.connect(lobby_code);
        
        console.log("conn: ", conn);
        // if (conn.open === false) {
        //     alert('Could not connect to lobby');
        //     return;
        // }
        
        conn.on('open', () => {
            userInput(myPlayer, conn);
            console.log('Connected to: ', conn.peer);
            conn.send({ type: 'initial_data_request' });
            conn.send({ type: 'playerConnect', myPlayer });
        });


        conn.on('error', (err) => {
            console.log('Connection error: ', err);
            alert('Could not connect to lobby'); // Notify the user
            go_to_lobby();
        });

        showGame();
            // Listen for data from the connection
        conn.on('data', function(data) {

            if (data.type === 'game_input_change') {
                game_input.value = data.message;
            }
            if (data.type === 'team_update') {
                red_team = data.red_team;
                blue_team = data.blue_team;
                spectators = data.spectators;
                updatePlayerList('Red', red_team);
                updatePlayerList('Blue', blue_team);
                updatePlayerList('Spectators', spectators);
                myPlayer.color = playerColor;
                conn.send({ type: 'playerConnect', myPlayer });
            }
            if (data.type === 'initial_data') {
                red_team = data.red_team;
                blue_team = data.blue_team;
                spectators = data.spectators;
                updatePlayerList('Red', red_team);
                updatePlayerList('Blue', blue_team);
                updatePlayerList('Spectators', spectators);
            }
            if (data.type === 'gameState') {
                renderGame(ctx, data.players, data.enemies, data.coins, data.missile, data.paused);
            }
            if (data.type === 'gameOver') {
                console.log('Game over: ', data.players);
                // Handle game over event
            }
        });

        // Send game input changes
        // game_input.addEventListener('input', function() {
        //     conn.send({ type: 'game_input_change', message: game_input.value });
        // });
    }

    

    const game = document.getElementById('game');

    function showGame() {
        lobby_modal.style.display = "none";
        lobby.style.display = "none";
        game.style.display = "grid";
        showGameModal();
    }

    function showGameModal() {
        const gameModal = document.getElementById('game_modal');
        gameModal.style.display = 'flex';
    }
    
    // Function to hide the game modal
    function hideGameModal() {
        const gameModal = document.getElementById('game_modal');
        gameModal.style.display = 'none';
    }

    // Event listeners for the team join buttons
    document.querySelectorAll('.game_modal_join_button').forEach(button => {
        button.addEventListener('click', function() {
            const team = this.classList.contains('red') ? 'Red Team' :
                        this.classList.contains('blue') ? 'Blue Team' : 'Spectators';
            joinTeam(team);
        });
    });

    // Function to handle joining a team
    function joinTeam(team) {
        console.log('Joining', team);
        // remove from existing team
        red_team = red_team.filter(player => player.peerId !== peerId);
        blue_team = blue_team.filter(player => player.peerId !== peerId);
        spectators = spectators.filter(player => player.peerId !== peerId);
        if (team === 'Red Team') {
            red_team.push({ name, peerId });
            playerColor = 'red';
        } else if (team === 'Blue Team') {
            blue_team.push({ name, peerId });
            playerColor = 'blue';
        } else {
            spectators.push({ name, peerId });
            playerColor = '';
        }

        if (conn) {
            conn.send({ type: 'team_update', red_team, blue_team, spectators });
        }  

        updatePlayerList('Red', red_team);
        updatePlayerList('Blue', blue_team);
        updatePlayerList('spectators', spectators);
        
        // Here you would add the logic to join the team
        // This would involve sending a message to the server with the peer ID and team choice
        // Then, the server would broadcast the updated team lists to all clients
    }

    // Function to update the player list in the modal
    function updatePlayerList(team, players) {
        const teamClass = `${team.toLowerCase()}_team`; // This will create 'red_team', 'spectators', or 'blue_team'
        const playerListDiv = document.querySelector(`.${teamClass}`);
        playerListDiv.innerHTML = ''; // Clear existing list
    
        players.forEach(player => {
            const playerDiv = document.createElement('div');
            playerDiv.classList.add('player'); // Add class for styling if necessary
            playerDiv.textContent = player.name; // Assuming 'player' is an object with a 'name' property
            playerListDiv.appendChild(playerDiv);
        });
    }
        

    // Event listener for the leave button
    document.getElementById('game_modal_leave_button').addEventListener('click', function() {
        hideGameModal();
        go_to_lobby();
        // Here you would add the logic to leave the team or game
    });

    document.getElementById('settingsButton').addEventListener('click', function() {
        showGameModal();
    });

    const gameModal = document.getElementById('game_modal');

    window.onclick = function(event) {
        if (event.target == gameModal) {
            hideGameModal();
        }
        if (event.target == lobby_modal) {
            lobby_modal.style.display = "none";
        }
    }

    // Call to show the game modal (for testing purposes)
    // In your application, you would call this when it's time to show the team selection
    //showGameModal();
    });
---- End of client.js ----

Filename: webworker.js
// gameWorker.js
let interval;

self.onmessage = function(e) {
    if (e.data.command === 'start') {
        const fps = e.data.fps || 60; // Default to 60 frames per second
        interval = setInterval(() => {
            // Post message back to main thread
            self.postMessage({ status: 'tick' });
        }, 1000 / fps);
    } else if (e.data.command === 'stop') {
        clearInterval(interval);
    }
};
---- End of webworker.js ----

Filename: game.css
#game {
    display: grid; /* Use grid layout */
    grid-template-columns: 1fr auto 1fr; /* Three columns */
    grid-template-rows: 1fr auto 1fr; /* Three rows */
    height: 100vh;
    width: 100vw;
    position: fixed;
    top: 0;
    left: 0;
    background-color: grey;
}

#game_canvas {
    grid-column: 2; /* Place canvas in the center column */
    grid-row: 2; /* Place canvas in the center row */
    /* justify-self: center;
    align-self: center; */
    border: 4px solid #000;
}

#playerInfoContainer {
    grid-column: 1; /* Place player info in the left column */
    grid-row: 2; /* Align with canvas row for vertical centering */
    display: flex;
    flex-direction: column;
    align-items: center; /* Center horizontally in the column */
    justify-content: center; /* Center vertically */
    gap: 10px;
    height: 100%; /* Take the full height of the grid area */
}

.player-info {
    padding: 10px;
    border: 1px solid #ccc;
    background-color: #f9f9f9;
    min-width: 100px;
}

/* Overall modal styling */
#game .modal {
    display: flex; /* Use flexbox for centering */
    position: fixed; /* Fix position to the viewport */
    z-index: 100; /* High z-index to ensure it's above other content */
    left: 0;
    top: 0;
    width: 100%; /* Span the full width of the viewport */
    height: 100%; /* Span the full height of the viewport */
    background-color: rgba(0, 0, 0, 0.4); /* Semi-transparent black background */
    align-items: center; /* Center content vertically */
    justify-content: center; /* Center content horizontally */
}

/* Modal content box styling */
.game_modal_content {
    background-color: #2c3e50; /* Dark blue background */
    border-radius: 8px; /* Rounded corners */
    width: 50%; /* Use half of the window width */
    max-width: 600px; /* Maximum width of modal */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Subtle shadow for depth */
    padding: 20px; /* Padding inside the modal content box */
}

/* Modal header styling */
.game_modal_header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid #4b6584; /* Border to separate the header from content */
    padding-bottom: 10px; /* Padding at the bottom of the header */
    margin-bottom: 20px; /* Margin below the header */
}

#game_modal_lobby_code {
    color: #f5f6fa; /* Light color for the lobby code */
    font-weight: bold;
}

.team-selection-leave-button {
    padding: 10px 20px;
    background-color: #e74c3c; /* Red color for leave button */
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.9rem;
}

.team-selection-leave-button:hover {
    background-color: #c0392b; /* Darker red on hover */
}

/* Team columns container */
.game_modal_team_selection {
    display: flex;
    justify-content: space-evenly; /* Space the team columns evenly */
}

/* Individual team column styling */
.team_column {
    flex-grow: 1; /* Allow each column to grow */
    text-align: center; /* Center text within the column */
    margin: 0 10px; /* Margin between columns */
}

.team_column h3 {
    color: white; /* White text for team names */
    margin-bottom: 10px; /* Space below the team name */
}

/* Team selection button styling */
.game_modal_join_button {
    padding: 15px 30px;
    margin: 10px 0; /* Vertical margin for buttons */
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 1rem;
    width: 100%; /* Full width for block appearance */
    box-sizing: border-box; /* Include padding in width calculation */
    transition: background-color 0.3s; /* Smooth transition for hover */
}

/* Individual button colors */
.red_team {
    background-color: #e74c3c; /* Red team column background */
}

.blue_team {
    background-color: #3498db; /* Blue team column background */
}

.spectators {
    background-color: #f1c40f; /* Spectators column background */
}

.game_modal_join_button:hover {
    opacity: 0.8; /* Transparency effect on hover */
}


/* Style for team join buttons */
.game_modal_join_button {
    padding: 10px 20px;
    margin-bottom: 15px; /* Space between button and player list */
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 1rem;
    width: 100%; /* Full width for block appearance */
    box-sizing: border-box; /* Include padding in width calculation */
    transition: background-color 0.3s; /* Smooth transition for hover */
}

/* Color for each team's join button */
.game_modal_join_button.red { background-color: #e74c3c; }
.game_modal_join_button.blue { background-color: #3498db; }
.game_modal_join_button.yellow { background-color: #f1c40f; }

/* Hover effect for join buttons */
.game_modal_join_button:hover {
    opacity: 0.8;
}

/* Style for player list columns */
.player_list {
    border: 1px solid #ccc; /* Border for the player list */
    border-radius: 4px; /* Rounded corners */
    padding: 10px; /* Padding inside the player list */
    margin-top: 10px; /* Space above the player list */
    background-color: #fff; /* White background for visibility */
    height: 150px; /* Fixed height, or you can make it flexible */
    overflow-y: auto; /* Allow scrolling for overflow */
}

#game .settings-button {
    position: absolute; /* Position the button absolutely within the #game div */
    top: 10px; /* Position it from the top inside the game div */
    right: 10px; /* Position it from the right inside the game div */
    padding: 10px 20px;
    background-color: #3498db; /* Blue background for the button */
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 1rem;
    z-index: 10; /* Make sure it's above other content in the game div */
}

#game .settings-button:hover {
    background-color: #2980b9; /* Darken button on hover */
}---- End of game.css ----

Filename: initial_page.css
body, html {
    height: 100%;
    margin: 0;
    font-family: 'Arial', sans-serif;
    background: grey;
}

header {
    background: rgba(0, 0, 0, 0.5);
    color: white;
    padding: 10px 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

header .logo {
    font-size: 2em;
    font-weight: bold;
    background: -webkit-linear-gradient(left, #f1c40f, #e67e22);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
}

.main {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100%;
}

.nickname_box {
    background: rgba(0, 0, 0, 0.7);
    border-radius: 5px;
    padding: 20px;
    text-align: center;
}

.nickname_box h1 {
    color: #fff;
}

.nickname_box input {
    width: 200px;
    padding: 10px;
    margin-top: 10px;
    border: none;
    border-radius: 5px;
}

.nickname_box button {
    width: 60px;
    padding: 10px;
    margin-top: 10px;
    background-color: #e67e22;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
}

.nickname_box button:hover {
    background-color: #f39c12;
}

---- End of initial_page.css ----

Filename: lobby.css
#lobby {
    display: none; /* This will be changed dynamically */
    flex-direction: column;
    align-items: center;
    padding: 20px;
    background: #2c3e50; /* Dark blue background */
    color: white;
}

.lobby-footer {
    display: flex;
    justify-content: center;
    margin-top: 20px;
}

.lobby-footer button {
    padding: 10px 20px;
    background-color: #3498db;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background-color 0.3s;
    margin-right: 10px; /* Add space between buttons */
}

.lobby-footer button:last-child {
    margin-right: 0; /* Remove margin from last button */
}

.lobby-footer button:hover {
    background-color: #2980b9;
}

/* Modal Styles */
#lobby .modal {
    display: none; /* Hidden by default */
    position: fixed; /* Stay in place */
    z-index: 1; /* Sit on top */
    left: 0;
    top: 0;
    width: 100%; /* Full width */
    height: 100%; /* Full height */
    overflow: auto; /* Enable scroll if needed */
    background-color: rgb(0, 0, 0); /* Fallback color */
    background-color: rgba(0, 0, 0, 0.4); /* Black w/ opacity */
}

#lobby .modal_content {
    background-color: #fefefe;
    margin: 15% auto; /* 15% from the top and centered */
    padding: 20px;
    border: 1px solid #888;
    width: 80%; /* Could be more or less, depending on screen size */
    max-width: 500px; /* Maximum width */
    border-radius: 5px;
    color: black; /* Text color for the modal */
}

#lobby .modal_content h2 {
    color: #333; /* Dark grey color for better contrast */
    margin-bottom: 20px; /* Spacing between title and content */
}

#lobby_modal_code {
    font-size: 1rem; /* Increase font size for better readability */
    border: 1px solid #ccc; /* Add border to the input */
    border-radius: 4px;
    padding: 10px;
    margin-bottom: 20px; /* Spacing between input and button */
    width: 70%; /* Width of input field */
    max-width: 400px; /* Maximum width of input field */
    display: inline-block; /* Make input inline for smaller screens */
}

#lobby button {
    background-color: #3498db; /* Primary button color */
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 1rem;
    transition: background-color 0.3s;
    margin: 5px; /* Space around buttons */
}

#lobby button:hover {
    background-color: #2980b9; /* Darken button on hover */
}

/* Copy button specific styles */
#lobby_modal_coppy_button {
    background-color: #2ecc71; /* Green color for success actions like copying */
    font-weight: bold; /* Make the 'Copy' text bold */
}

#lobby_modal_coppy_button:hover {
    background-color: #27ae60; /* Darken the green on hover */
}

/* Start Game button specific styles */
#lobby_modal_button {
    background-color: #e67e22; /* Orange color to highlight primary action */
    font-weight: bold; /* Make the 'Start Game' text bold */
}

#lobby_modal_button:hover {
    background-color: #d35400; /* Darken the orange on hover */
}



#lobby_modal_input {
    font-size: 1rem; /* Increase font size for better readability */
    border: 1px solid #ccc; /* Add border to the input */
    border-radius: 4px;
    padding: 10px;
    margin-bottom: 20px; /* Spacing between input and button */
    width: 70%; /* Width of input field */
    max-width: 400px; /* Maximum width of input field */
    display: inline-block; /* Make input inline for smaller screens */
}
---- End of lobby.css ----

